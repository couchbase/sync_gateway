// Copyright 2024-Present Couchbase, Inc.
//
// Use of this software is governed by the Business Source License included
// in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
// in that file, in accordance with the Business Source License, use of this
// software will be governed by the Apache License, Version 2.0, included in
// the file licenses/APL2.txt.

package base

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"slices"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/exp/maps"
)

func TestValidateAuditEvents(t *testing.T) {
	// Ensures that the above audit event IDs are within the allocated range and are valid.
	require.NoError(t, validateAuditEvents(AuditEvents))
}

func validateAuditEvents(e events) error {
	multiError := &MultiError{}
	seenIDs := make(map[AuditID]struct{})
	for id, descriptor := range e {
		if id < auditdSyncGatewayStartID || id > auditdSyncGatewayEndID {
			multiError = multiError.Append(fmt.Errorf("invalid audit event ID: %d %q (allowed range: %d-%d)",
				id, descriptor.Name, auditdSyncGatewayStartID, auditdSyncGatewayEndID))
		}
		if _, ok := seenIDs[id]; ok {
			multiError = multiError.Append(fmt.Errorf("duplicate audit event ID: %d %q", id, descriptor.Name))
		}
		seenIDs[id] = struct{}{}
	}
	return multiError.ErrorOrNil()
}

// TestGenerateAuditDescriptorCSV outputs a CSV of AuditEvents.
func TestGenerateAuditDescriptorCSV(t *testing.T) {
	fmt.Printf("\"Note:\",\"Data generated by %s\"\n", t.Name())
	fmt.Printf("\"Updated:\",\"%s\"\n", time.Now().UTC().Format(time.RFC3339))
	b, err := generateCSVModuleDescriptor(AuditEvents)
	require.NoError(t, err)
	fmt.Print(string(b))
}

// generateCSVModuleDescriptor returns a CSV module descriptor for the given events.
func generateCSVModuleDescriptor(e events) ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	w := csv.NewWriter(buf)

	// Write header
	if err := w.Write([]string{"ID", "Name", "Description", "DefaultEnabled", "Filterable", "EventType", "MandatoryFields", "OptionalFields"}); err != nil {
		return nil, err
	}

	keys := make([]AuditID, 0, len(e))
	for k := range e {
		keys = append(keys, k)
	}
	slices.Sort(keys)

	for _, id := range keys {
		event := e[id]

		mandatoryFields := event.MandatoryFields
		mandatoryFieldKeys := maps.Keys(mandatoryFields)
		slices.Sort(mandatoryFieldKeys)
		optionalFields := event.OptionalFields
		optionalFieldKeys := maps.Keys(optionalFields)
		slices.Sort(optionalFieldKeys)
		if err := w.Write([]string{
			id.String(),
			event.Name,
			event.Description,
			strconv.FormatBool(event.EnabledByDefault),
			strconv.FormatBool(event.FilteringPermitted),
			string(event.EventType),
			strings.Join(mandatoryFieldKeys, ", "),
			strings.Join(optionalFieldKeys, ", "),
		}); err != nil {
			return nil, err
		}
	}

	w.Flush()
	if err := w.Error(); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func TestNonFilterableAuditEventsForScope(t *testing.T) {
	tests := []struct {
		name                    string
		events                  events
		wantGlobalNonFilterable map[AuditID]struct{}
		wantDbNonFilterable     map[AuditID]struct{}
	}{
		{
			name: "filterable events (db-scoped)",
			events: events{
				1: {Name: "event1", FilteringPermitted: true},
				2: {Name: "event2", FilteringPermitted: true},
			},
			wantGlobalNonFilterable: map[AuditID]struct{}{},
			wantDbNonFilterable:     map[AuditID]struct{}{},
		},
		{
			name: "non-filterable events (db-scoped)",
			events: events{
				1: {Name: "event1", FilteringPermitted: false},
				2: {Name: "event2", FilteringPermitted: false},
			},
			wantGlobalNonFilterable: map[AuditID]struct{}{},
			wantDbNonFilterable:     map[AuditID]struct{}{1: {}, 2: {}},
		},
		{
			name: "non-filterable events one global",
			events: events{
				1: {Name: "event1", FilteringPermitted: false, IsGlobalEvent: true},
				2: {Name: "event2", FilteringPermitted: false},
			},
			wantGlobalNonFilterable: map[AuditID]struct{}{1: {}},
			wantDbNonFilterable:     map[AuditID]struct{}{2: {}},
		},
		{
			name: "two filterable events one global",
			events: events{
				1: {Name: "event1", FilteringPermitted: true, IsGlobalEvent: true},
				2: {Name: "event2", FilteringPermitted: true},
			},
			wantGlobalNonFilterable: map[AuditID]struct{}{},
			wantDbNonFilterable:     map[AuditID]struct{}{},
		},
		{
			name: "two filterable global events",
			events: events{
				1: {Name: "event1", FilteringPermitted: true, IsGlobalEvent: true},
				2: {Name: "event2", FilteringPermitted: true, IsGlobalEvent: true},
			},
			wantGlobalNonFilterable: map[AuditID]struct{}{},
			wantDbNonFilterable:     map[AuditID]struct{}{},
		},
	}
	for _, tt := range tests {
		for _, global := range []bool{true, false} {
			testName := tt.name + "-global=" + strconv.FormatBool(global)
			t.Run(testName, func(t *testing.T) {
				nonFilterable := nonFilterableAuditEventsForScope(tt.events, global)
				if global {
					assert.Equal(t, tt.wantGlobalNonFilterable, nonFilterable)
				} else {
					assert.Equal(t, tt.wantDbNonFilterable, nonFilterable)
				}
			})
		}
	}
}
