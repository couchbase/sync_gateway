package functions

import (
	_ "embed"
	"encoding/json"
	"fmt"

	v8 "rogchap.com/v8go" // Docs: https://pkg.go.dev/rogchap.com/v8go
)

// The JavaScript code run in a context, that defines the API, embedded in a string constant.
// `main.js` is generated by WebPack from the TypeScript sources; see engine/webpack.config.js.
//
//go:embed engine/dist/main.js
var kJavaScriptCode string

// Used to pass configuration to V8. Equivalent to TypeScript type `Config` in types.ts
type jsConfig struct {
	Functions *FunctionsConfig `json:"functions,omitempty"`
	Graphql   *GraphQLConfig   `json:"graphql,omitempty"`
}

//////// ENVIRONMENT

// Represents a V8 JavaScript VM (aka "Isolate".)
// This doesn't do much on its own; its purpose is to perform shared initialization that makes creating an Evaluator faster.
// **Not thread-safe! Must be called only on one goroutine at a time.**
type environment struct {
	jsonConfig       *v8.Value          // JSON-encoded functions/graphql config
	vm               *v8.Isolate        // A V8 virtual machine. NOT THREAD SAFE.
	global           *v8.ObjectTemplate // The global namespace (a template)
	script           *v8.UnboundScript  // Compiled JS code; template run in each new context
	jsNativeTemplate *v8.ObjectTemplate // Template of JS "NativeAPI" object
	curEvaluator     *evaluator
}

// Constructs an Environment given the configuration.
func newEnvironment(functions *FunctionsConfig, graphql *GraphQLConfig) (*environment, error) {
	// Encode the config as JSON:
	jsonConfig, err := json.Marshal(jsConfig{functions, graphql})
	if err != nil {
		return nil, err
	}
	return newEnvironmentFromJSON(string(jsonConfig))
}

// Constructs an Environment given the JSON-encoded configuration.
func newEnvironmentFromJSON(jsonConfig string) (*environment, error) {
	// Create a V8 VM ("isolate"):
	vm := v8.NewIsolate()
	env := &environment{
		vm:         vm,
		global:     v8.NewObjectTemplate(vm),
		jsonConfig: goToV8String(vm, string(jsonConfig)),
	}

	// Create the top-level 'process' namespace that Apollo's libraries expect.
	processTemplate := v8.NewObjectTemplate(env.vm)
	env.global.Set("process", processTemplate)
	processTemplate.Set("env", v8.NewObjectTemplate(env.vm))

	// Compile the engine's JS code. This code just defines a library; to get access to the entry point, we append the expression `SG_Engine.main` so the result of running the script is a pointer to the `main` function. (The script runs later, in `NewEvaluator`.)
	var err error
	env.script, err = vm.CompileUnboundScript(kJavaScriptCode+"\n SG_Engine.main;", "main.js", v8.CompileOptions{})
	if err != nil {
		return nil, err
	}

	// Create the JS "NativeAPI" object template, with Go callback methods:
	env.jsNativeTemplate = v8.NewObjectTemplate(vm)
	env.defineEvaluatorCallback(env.jsNativeTemplate, "query", doQuery)
	env.defineEvaluatorCallback(env.jsNativeTemplate, "get", doGet)
	env.defineEvaluatorCallback(env.jsNativeTemplate, "save", doSave)
	env.defineEvaluatorCallback(env.jsNativeTemplate, "delete", doDelete)
	env.defineEvaluatorCallback(env.jsNativeTemplate, "log", doLog)

	return env, nil
}

// Cleans up an Environment by disposing the V8 runtime.
func (env *environment) close() {
	env.vm.Dispose()
}

// Returns the Evaluator that owns the given V8 Context.
func (env *environment) getEvaluator(ctx *v8.Context) *evaluator {
	// IMPORTANT: This is kind of a hack, because we expect only one Evaluator at a time.
	// If there were to be multiple Evaluators, we'd need to maintain a map from contexts to Evaluators.
	if env.curEvaluator == nil {
		panic(fmt.Sprintf("Unknown v8.Context passed to Environment.getEvaluator: %v, expected none", ctx))
	}
	if ctx != env.curEvaluator.ctx {
		panic(fmt.Sprintf("Unknown v8.Context passed to Environment.getEvaluator: %v, expected %v", ctx, env.curEvaluator.ctx))
	}
	return env.curEvaluator
}

//////// ENVIRONMENT POOL

// Thread-safe wrapper that vends `evaluator` objects.
type environmentPool struct {
	jsonConfig   string
	environments chan *environment
}

// Creates an `environmentPool`, a thread-safe wrapper around `environment`.
// `maxEnvironments` is the maximum number of `environment` objects (and V8 instances!) it will cache.
func newEnvironmentPool(functions *FunctionsConfig, graphql *GraphQLConfig, maxEnvironments int) (*environmentPool, error) {
	// Encode the config as JSON:
	jsonConfig, err := json.Marshal(jsConfig{functions, graphql})
	if err != nil {
		return nil, err
	}
	return &environmentPool{
		jsonConfig:   string(jsonConfig),
		environments: make(chan *environment, maxEnvironments),
	}, nil
}

// Produces an `evaluator` that can be used by this goroutine.
// It should be returned when done by calling `returnEvaluator` to avoid wasting memory.
func (ep *environmentPool) getEvaluator(delegate evaluatorDelegate, user *userCredentials) (*evaluator, error) {
	var env *environment
	select {
	case env = <-ep.environments:
		break
	default:
		// If pool is empty, create a new environment.
		// (If this bloats memory, it might be better to block until one is returned...)
		var err error
		if env, err = newEnvironmentFromJSON(ep.jsonConfig); err != nil {
			return nil, err
		}
	}
	return env.newEvaluator(delegate, user)
}

// Returns a used `evaluator` back to the pool for reuse.
func (ep *environmentPool) returnEvaluator(eval *evaluator) {
	if eval != nil && eval.env != nil {
		env := eval.env
		eval.close()

		select {
		case ep.environments <- env:
		default:
			// Drop it on the floor if the pool is already full
		}
	}
}

// Frees up the cached V8 VMs of an `environmentPool`
func (ep *environmentPool) close() {
	for {
		select {
		case env := <-ep.environments:
			env.close()
		default:
			return
		}
	}
}
