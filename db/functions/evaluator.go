package functions

import (
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"log"
	"strings"

	"github.com/couchbase/sync_gateway/base"
	"github.com/couchbase/sync_gateway/db"
	"github.com/couchbase/sync_gateway/js"
	v8 "rogchap.com/v8go" // Docs: https://pkg.go.dev/rogchap.com/v8go
)

// The JavaScript code run in a context, that defines the API, embedded in a string constant.
// `main.js` is generated by WebPack from the TypeScript sources; see engine/webpack.config.js.
//
//go:embed engine/dist/main.js
var kJavaScriptCode string

// Used for JSON-encoding configuration for engine.
// Equivalent to TypeScript type `Config` in types.ts
type jsConfig struct {
	Functions *FunctionsConfig `json:"functions,omitempty"`
	GraphQL   *GraphQLConfig   `json:"graphql,omitempty"`
}

// js.Service implementation; a "subclass" of js.BaseService.
type functionService struct {
	*js.BasicService                    // "Superclass"
	upstreamTemplate *v8.ObjectTemplate // Template of object holding JS callbacks
	jsonConfig       *v8.Value          // JSON configuration string
}

// Returns a ServiceFactory function that instantiates a "functions" js.Service
func makeService(functions *FunctionsConfig, graphql *GraphQLConfig) js.ServiceFactory {
	return func(base *js.BasicService) (js.Service, error) {
		// Initialize the BaseService and compile the JS code:
		base.SetScript(kJavaScriptCode + "\n SG_Engine.main;")

		// Create the top-level 'process' namespace that Apollo's libraries expect:
		process := base.NewObjectTemplate()
		process.Set("env", base.NewObjectTemplate())
		mustNoError(base.Global().Set("process", process))

		// Create the template for the "upstream" object containing the callbacks to Go:
		upstream := base.NewObjectTemplate()
		upstream.Set("query", base.NewCallback(doQuery))
		upstream.Set("get", base.NewCallback(doGet))
		upstream.Set("save", base.NewCallback(doSave))
		upstream.Set("delete", base.NewCallback(doDelete))

		// Create a JS string of the configuration JSON:
		jsonConfig := mustSucceed(json.Marshal(jsConfig{Functions: functions, GraphQL: graphql}))

		// Wrap the service in a js.Service implementation:
		return &functionService{
			BasicService:     base,
			upstreamTemplate: upstream,
			jsonConfig:       base.NewString(string(jsonConfig)),
		}, nil
	}
}

//////// EVALUATOR

// A JavaScript execution context in an Environment. This is what actually does the work.
// It wraps a js.Runner that was instantiated from the functionService.
// **Not thread-safe! Must be called only on one goroutine at a time. In fact, all Evaluators created from the same Environment must be called only one one goroutine.**
type evaluator struct {
	runner          *js.Runner        // The V8 context
	api             *v8.Object        // JavaScript `API` object (see api.ts)
	functionFn      *v8.Function      // JavaScript `API.callFunction()` function
	graphqlFn       *v8.Function      // JavaScript `API.graphql()` function
	delegate        evaluatorDelegate // Provides native callbacks like the CRUD API
	user            *userCredentials  // Name & capabilities of the calling user
	mutationAllowed bool              // Is the Evaluator allowed to make mutating calls?
}

// Pluggable implementation of native functionality the JS code calls -- CRUD, query, logging.
type evaluatorDelegate interface {
	// Return an error if evaluation has gone on too long.
	checkTimeout() error

	// Perform a N1QL query.
	query(fnName string, n1ql string, args map[string]any, asAdmin bool) (rowsAsJSON string, err error)

	// Get a document.
	get(docID string, asAdmin bool) (doc map[string]any, err error)
	// Save/create a document.
	save(doc map[string]any, docID string, asAdmin bool) (saved bool, err error)
	// Delete a document.
	delete(docID string, revID string, asAdmin bool) (ok bool, err error)
}

// Name and capabilities of the current user. (Admin is represented by a nil `*userCredentials`.)
type userCredentials struct {
	Name     string
	Roles    []string
	Channels []string
}

func makeEvaluator(dbc *db.Database, delegate evaluatorDelegate, user *userCredentials, ctx context.Context) (*evaluator, error) {
	runner, err := dbc.V8VMs.GetRunner("functions")
	if err != nil {
		return nil, err
	}

	if dbc.Options.JavascriptTimeout > 0 {
		var cancelFn context.CancelFunc
		ctx, cancelFn = context.WithTimeout(ctx, dbc.Options.JavascriptTimeout)
		defer cancelFn()
	}
	runner.SetContext(ctx)

	if eval, ok := runner.Client.(*evaluator); ok {
		eval.user = user
		return eval, nil
	} else {
		return newEvaluator(runner, delegate, user)
	}
}

// Creates an Evaluator, wrapping a js.Runner.
func newEvaluator(runner *js.Runner, delegate evaluatorDelegate, user *userCredentials) (*evaluator, error) {
	eval := &evaluator{
		runner:   runner,
		delegate: delegate,
		user:     user,
	}
	runner.Client = eval

	// Call the JS initialization code, passing it the configuration and the Upstream.
	// This returns the JS `API` object.
	fnService := runner.Service().(*functionService)
	if fnService == nil {
		panic("Couldn't cast to functionService")
	}
	upstream, err := runner.NewInstance(fnService.upstreamTemplate)
	if err != nil {
		return nil, err
	}
	eval.api, err = runner.RunAsObject(fnService.jsonConfig, upstream)
	if err != nil {
		return nil, err
	}

	// Check the API.errors property for configuration errors:
	if errorsVal, err := eval.api.Get("errors"); err != nil {
		return nil, err
	} else if errorsObj, _ := errorsVal.AsObject(); errorsObj != nil {
		var errors base.MultiError
		var i uint32
		for i = 0; errorsObj.HasIdx(i); i++ {
			if errorVal, err := errorsObj.GetIdx(i); err == nil {
				errors.Append(fmt.Errorf(errorVal.String()))
			}
		}
		return nil, &errors
	}

	eval.functionFn = mustGetV8Fn(eval.api, "callFunction")
	eval.graphqlFn = mustGetV8Fn(eval.api, "graphql")
	return eval, nil
}

// Disposes the V8 resources for an Evaluator. Always call this when done.
func (eval *evaluator) close() {
	eval.runner.Return()
}

// Configures whether the Evaluator is allowed to mutate the database; if false (the default), calls to `save()` and `delete()` will fail.
func (eval *evaluator) setMutationAllowed(allowed bool) {
	eval.mutationAllowed = allowed
}

// Returns the current user.
func (eval *evaluator) GetUser() *userCredentials {
	return eval.user
}

// Calls a named function. Result is returned as a JSON string.
func (eval *evaluator) callFunction(name string, args map[string]any) ([]byte, error) {
	user, roles, channels := eval.v8Credentials()
	// Calling JS method API.callFunction (api.ts)
	v8Result, err := eval.runner.Call(eval.functionFn, eval.api,
		eval.runner.NewString(name),
		mustSucceed(eval.runner.NewJSONString(args)),
		user, roles, channels,
		mustSucceed(eval.runner.NewValue(eval.mutationAllowed)))

	if err == nil {
		if result, err := js.StringToGo(v8Result); err == nil {
			return result, nil
		}
	}
	return nil, js.UnpackError(err)
}

// Performs a GraphQL query. Result is an object of the usual GraphQL result shape, i.e. with `data` and/or `errors` properties. It is returned as a JSON string.
func (eval *evaluator) callGraphQL(query string, operationName string, variables map[string]any) ([]byte, error) {
	user, roles, channels := eval.v8Credentials()
	// Calling JS method API.callGraphQL (api.ts)
	v8Result, err := eval.runner.Call(eval.graphqlFn, eval.api,
		eval.runner.NewString(query),
		eval.runner.NewString(operationName),
		mustSucceed(eval.runner.NewJSONString(variables)),
		user, roles, channels,
		mustSucceed(eval.runner.NewValue(eval.mutationAllowed)))
	if err == nil {
		var result []byte
		if result, err = js.StringToGo(v8Result); err == nil {
			return result, nil
		}
	}
	return nil, js.UnpackError(err)
}

// Encodes credentials as 3 parameters to pass to JS.
func (eval *evaluator) v8Credentials() (user *v8.Value, roles *v8.Value, channels *v8.Value) {
	undef, _ := eval.runner.NewValue(nil)
	if eval.user != nil {
		user = eval.runner.NewString(eval.user.Name)
	} else {
		user = undef
	}
	if eval.user != nil && len(eval.user.Roles) > 0 {
		roles = eval.runner.NewString(strings.Join(eval.user.Roles, ","))
	} else {
		roles = undef
	}
	if eval.user != nil && len(eval.user.Channels) > 0 {
		channels = eval.runner.NewString(strings.Join(eval.user.Channels, ","))
	} else {
		channels = undef
	}
	return
}

//////// EVALUATOR CALLBACK IMPLEMENTATIONS:

// 	query(fnName: string, n1ql: string, argsJSON: string | undefined, asAdmin: boolean) : string;
func doQuery(r *js.Runner, info *v8.FunctionCallbackInfo) (any, error) {
	fnName := info.Args()[0].String()
	n1ql := info.Args()[1].String()
	args, err := js.JSONToGoMap(info.Args()[2])
	if err != nil {
		return nil, err
	}
	asAdmin := info.Args()[3].Boolean()
	eval := r.Client.(*evaluator)
	return eval.delegate.query(fnName, n1ql, args, asAdmin)
}

// 	get(docID: string, asAdmin: boolean) : string | null;
func doGet(r *js.Runner, info *v8.FunctionCallbackInfo) (any, error) {
	docID := info.Args()[0].String()
	asAdmin := info.Args()[1].Boolean()
	eval := r.Client.(*evaluator)
	return returnAsJSON(eval.delegate.get(docID, asAdmin))
}

// 	save(docJSON: string, docID: string | undefined, asAdmin: boolean) : string | null;
func doSave(r *js.Runner, info *v8.FunctionCallbackInfo) (any, error) {
	var docID string
	doc, err := js.JSONToGoMap(info.Args()[0])
	if err != nil {
		return nil, err
	}
	if arg1 := info.Args()[1]; arg1.IsString() {
		docID = arg1.String()
	} else if _id, found := doc["_id"].(string); found {
		docID = _id
	} else {
		docID, err = base.GenerateRandomID()
		if err != nil {
			return nil, err
		}
	}
	asAdmin := info.Args()[2].Boolean()

	eval := r.Client.(*evaluator)
	if saved, err := eval.delegate.save(doc, docID, asAdmin); saved && err == nil {
		return docID, nil
	} else {
		return nil, err
	}
}

// 	delete(docID: string, revID: string | undefined, asAdmin: boolean) : boolean;
func doDelete(r *js.Runner, info *v8.FunctionCallbackInfo) (any, error) {
	docID := info.Args()[0].String()
	var revID string
	if arg1 := info.Args()[1]; arg1.IsString() {
		revID = arg1.String()
	}
	asAdmin := info.Args()[2].Boolean()
	eval := r.Client.(*evaluator)
	return eval.delegate.delete(docID, revID, asAdmin)
}

//////// UTILITIES

// Simple utility to wrap a function that returns a value and an error; returns just the value, panicking if there was an error.
// This is kind of equivalent to those 3-prong to 2-prong electric plug adapters...
// Needless to say, it should only be used if you know the error cannot occur, or that if it occurs something is very, very wrong.
func mustSucceed[T any](result T, err error) T {
	if err != nil {
		log.Fatalf("ASSERTION FAILURE: expected a %T, got %v", result, err)
	}
	return result
}

func mustNoError(err error) {
	if err != nil {
		log.Fatalf("ASSERTION FAILURE: unexpected error %v", err)
	}
}

// Gets a named method of a JS object. Panics if not found.
func mustGetV8Fn(owner *v8.Object, name string) *v8.Function {
	fnVal := mustSucceed(owner.Get(name))
	return mustSucceed(fnVal.AsFunction())
}

// Converts a result and error to a JSON-encoded string and error.
// - If `err` is non-nil on input, just passes it through.
// - Otherwise it JSON-encodes the `result` and returns it.
func returnAsJSON(result any, err error) (any, error) {
	if result == nil || err != nil {
		return nil, err
	} else if jsonBytes, err := json.Marshal(result); err != nil {
		return nil, err
	} else {
		return string(jsonBytes), nil
	}
}
